// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cmcdata.proto

#include "cmcdata.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr HashSlotInfo_CacheNodeInfo::HashSlotInfo_CacheNodeInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , slots_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , port_(0){}
struct HashSlotInfo_CacheNodeInfoDefaultTypeInternal {
  constexpr HashSlotInfo_CacheNodeInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HashSlotInfo_CacheNodeInfoDefaultTypeInternal() {}
  union {
    HashSlotInfo_CacheNodeInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HashSlotInfo_CacheNodeInfoDefaultTypeInternal _HashSlotInfo_CacheNodeInfo_default_instance_;
constexpr HashSlotInfo::HashSlotInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cache_nodes_()
  , cache_node_(nullptr)
  , hashinfo_type_(0)
{}
struct HashSlotInfoDefaultTypeInternal {
  constexpr HashSlotInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HashSlotInfoDefaultTypeInternal() {}
  union {
    HashSlotInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HashSlotInfoDefaultTypeInternal _HashSlotInfo_default_instance_;
constexpr CommandInfo::CommandInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : param1_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , param2_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cmd_type_(0)
{}
struct CommandInfoDefaultTypeInternal {
  constexpr CommandInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CommandInfoDefaultTypeInternal() {}
  union {
    CommandInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CommandInfoDefaultTypeInternal _CommandInfo_default_instance_;
constexpr KvData::KvData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct KvDataDefaultTypeInternal {
  constexpr KvDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KvDataDefaultTypeInternal() {}
  union {
    KvData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KvDataDefaultTypeInternal _KvData_default_instance_;
constexpr HeartInfo::HeartInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cur_time_(0)
  , cache_status_(0)
{}
struct HeartInfoDefaultTypeInternal {
  constexpr HeartInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~HeartInfoDefaultTypeInternal() {}
  union {
    HeartInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT HeartInfoDefaultTypeInternal _HeartInfo_default_instance_;
constexpr AckInfo::AckInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ack_type_(0)

  , ack_status_(0)
{}
struct AckInfoDefaultTypeInternal {
  constexpr AckInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AckInfoDefaultTypeInternal() {}
  union {
    AckInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AckInfoDefaultTypeInternal _AckInfo_default_instance_;
constexpr CMCData::CMCData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hs_info_(nullptr)
  , cmd_info_(nullptr)
  , kv_data_(nullptr)
  , ht_info_(nullptr)
  , ack_info_(nullptr)
  , data_type_(0)
{}
struct CMCDataDefaultTypeInternal {
  constexpr CMCDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMCDataDefaultTypeInternal() {}
  union {
    CMCData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMCDataDefaultTypeInternal _CMCData_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_cmcdata_2eproto[7];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_cmcdata_2eproto[6];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_cmcdata_2eproto = nullptr;

const uint32_t TableStruct_cmcdata_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HashSlotInfo_CacheNodeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HashSlotInfo_CacheNodeInfo, name_),
  PROTOBUF_FIELD_OFFSET(::HashSlotInfo_CacheNodeInfo, ip_),
  PROTOBUF_FIELD_OFFSET(::HashSlotInfo_CacheNodeInfo, port_),
  PROTOBUF_FIELD_OFFSET(::HashSlotInfo_CacheNodeInfo, slots_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HashSlotInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HashSlotInfo, hashinfo_type_),
  PROTOBUF_FIELD_OFFSET(::HashSlotInfo, cache_nodes_),
  PROTOBUF_FIELD_OFFSET(::HashSlotInfo, cache_node_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CommandInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CommandInfo, cmd_type_),
  PROTOBUF_FIELD_OFFSET(::CommandInfo, param1_),
  PROTOBUF_FIELD_OFFSET(::CommandInfo, param2_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::KvData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::KvData, key_),
  PROTOBUF_FIELD_OFFSET(::KvData, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::HeartInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::HeartInfo, cur_time_),
  PROTOBUF_FIELD_OFFSET(::HeartInfo, cache_status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AckInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AckInfo, ack_type_),
  PROTOBUF_FIELD_OFFSET(::AckInfo, ack_status_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMCData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMCData, data_type_),
  PROTOBUF_FIELD_OFFSET(::CMCData, hs_info_),
  PROTOBUF_FIELD_OFFSET(::CMCData, cmd_info_),
  PROTOBUF_FIELD_OFFSET(::CMCData, kv_data_),
  PROTOBUF_FIELD_OFFSET(::CMCData, ht_info_),
  PROTOBUF_FIELD_OFFSET(::CMCData, ack_info_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::HashSlotInfo_CacheNodeInfo)},
  { 10, -1, -1, sizeof(::HashSlotInfo)},
  { 19, -1, -1, sizeof(::CommandInfo)},
  { 28, -1, -1, sizeof(::KvData)},
  { 36, -1, -1, sizeof(::HeartInfo)},
  { 44, -1, -1, sizeof(::AckInfo)},
  { 52, -1, -1, sizeof(::CMCData)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_HashSlotInfo_CacheNodeInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_HashSlotInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CommandInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_KvData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_HeartInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AckInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMCData_default_instance_),
};

const char descriptor_table_protodef_cmcdata_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rcmcdata.proto\"\274\002\n\014HashSlotInfo\0221\n\rhash"
  "info_type\030\001 \001(\0162\032.HashSlotInfo.HashInfoT"
  "ype\0220\n\013cache_nodes\030\002 \003(\0132\033.HashSlotInfo."
  "CacheNodeInfo\022/\n\ncache_node\030\003 \001(\0132\033.Hash"
  "SlotInfo.CacheNodeInfo\032F\n\rCacheNodeInfo\022"
  "\014\n\004name\030\001 \001(\t\022\n\n\002ip\030\002 \001(\t\022\014\n\004port\030\003 \001(\005\022"
  "\r\n\005slots\030\004 \001(\014\"N\n\014HashInfoType\022\020\n\014NULLHA"
  "SHINFO\020\000\022\020\n\014ALLCACHEINFO\020\001\022\014\n\010ADDCACHE\020\002"
  "\022\014\n\010REMCACHE\020\003\"\242\001\n\013CommandInfo\022&\n\010cmd_ty"
  "pe\030\001 \001(\0162\024.CommandInfo.CmdType\022\016\n\006param1"
  "\030\002 \001(\t\022\016\n\006param2\030\003 \001(\t\"K\n\007CmdType\022\013\n\007NUL"
  "LCMD\020\000\022\007\n\003GET\020\001\022\007\n\003SET\020\002\022\007\n\003DEL\020\003\022\013\n\007GET"
  "SLOT\020\004\022\013\n\007OFFLINE\020\005\"$\n\006KvData\022\013\n\003key\030\001 \001"
  "(\t\022\r\n\005value\030\002 \001(\t\"|\n\tHeartInfo\022\020\n\010cur_ti"
  "me\030\001 \001(\005\022,\n\014cache_status\030\002 \001(\0162\026.HeartIn"
  "fo.CacheStatus\"/\n\013CacheStatus\022\016\n\nNULLSTA"
  "TUS\020\000\022\006\n\002OK\020\001\022\010\n\004FAIL\020\002\"\313\001\n\007AckInfo\022\"\n\010a"
  "ck_type\030\001 \001(\0162\020.AckInfo.AckType\022&\n\nack_s"
  "tatus\030\002 \001(\0162\022.AckInfo.AckStatus\"E\n\007AckTy"
  "pe\022\013\n\007NULLACK\020\000\022\n\n\006SETACK\020\001\022\n\n\006DELACK\020\002\022"
  "\025\n\021HASHSLOTUPDATEACK\020\003\"-\n\tAckStatus\022\016\n\nN"
  "ULLSTATUS\020\000\022\006\n\002OK\020\001\022\010\n\004FAIL\020\002\"\247\002\n\007CMCDat"
  "a\022$\n\tdata_type\030\001 \001(\0162\021.CMCData.DataType\022"
  "\036\n\007hs_info\030\002 \001(\0132\r.HashSlotInfo\022\036\n\010cmd_i"
  "nfo\030\003 \001(\0132\014.CommandInfo\022\030\n\007kv_data\030\004 \001(\013"
  "2\007.KvData\022\033\n\007ht_info\030\005 \001(\0132\n.HeartInfo\022\032"
  "\n\010ack_info\030\006 \001(\0132\010.AckInfo\"c\n\010DataType\022\014"
  "\n\010NULLTYPE\020\000\022\017\n\013COMMANDINFO\020\001\022\n\n\006KVDATA\020"
  "\002\022\020\n\014HASHSLOTINFO\020\003\022\r\n\tHEARTINFO\020\004\022\013\n\007AC"
  "KINFO\020\005b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_cmcdata_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cmcdata_2eproto = {
  false, false, 1175, descriptor_table_protodef_cmcdata_2eproto, "cmcdata.proto", 
  &descriptor_table_cmcdata_2eproto_once, nullptr, 0, 7,
  schemas, file_default_instances, TableStruct_cmcdata_2eproto::offsets,
  file_level_metadata_cmcdata_2eproto, file_level_enum_descriptors_cmcdata_2eproto, file_level_service_descriptors_cmcdata_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_cmcdata_2eproto_getter() {
  return &descriptor_table_cmcdata_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_cmcdata_2eproto(&descriptor_table_cmcdata_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HashSlotInfo_HashInfoType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_cmcdata_2eproto);
  return file_level_enum_descriptors_cmcdata_2eproto[0];
}
bool HashSlotInfo_HashInfoType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr HashSlotInfo_HashInfoType HashSlotInfo::NULLHASHINFO;
constexpr HashSlotInfo_HashInfoType HashSlotInfo::ALLCACHEINFO;
constexpr HashSlotInfo_HashInfoType HashSlotInfo::ADDCACHE;
constexpr HashSlotInfo_HashInfoType HashSlotInfo::REMCACHE;
constexpr HashSlotInfo_HashInfoType HashSlotInfo::HashInfoType_MIN;
constexpr HashSlotInfo_HashInfoType HashSlotInfo::HashInfoType_MAX;
constexpr int HashSlotInfo::HashInfoType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommandInfo_CmdType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_cmcdata_2eproto);
  return file_level_enum_descriptors_cmcdata_2eproto[1];
}
bool CommandInfo_CmdType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CommandInfo_CmdType CommandInfo::NULLCMD;
constexpr CommandInfo_CmdType CommandInfo::GET;
constexpr CommandInfo_CmdType CommandInfo::SET;
constexpr CommandInfo_CmdType CommandInfo::DEL;
constexpr CommandInfo_CmdType CommandInfo::GETSLOT;
constexpr CommandInfo_CmdType CommandInfo::OFFLINE;
constexpr CommandInfo_CmdType CommandInfo::CmdType_MIN;
constexpr CommandInfo_CmdType CommandInfo::CmdType_MAX;
constexpr int CommandInfo::CmdType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HeartInfo_CacheStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_cmcdata_2eproto);
  return file_level_enum_descriptors_cmcdata_2eproto[2];
}
bool HeartInfo_CacheStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr HeartInfo_CacheStatus HeartInfo::NULLSTATUS;
constexpr HeartInfo_CacheStatus HeartInfo::OK;
constexpr HeartInfo_CacheStatus HeartInfo::FAIL;
constexpr HeartInfo_CacheStatus HeartInfo::CacheStatus_MIN;
constexpr HeartInfo_CacheStatus HeartInfo::CacheStatus_MAX;
constexpr int HeartInfo::CacheStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AckInfo_AckType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_cmcdata_2eproto);
  return file_level_enum_descriptors_cmcdata_2eproto[3];
}
bool AckInfo_AckType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AckInfo_AckType AckInfo::NULLACK;
constexpr AckInfo_AckType AckInfo::SETACK;
constexpr AckInfo_AckType AckInfo::DELACK;
constexpr AckInfo_AckType AckInfo::HASHSLOTUPDATEACK;
constexpr AckInfo_AckType AckInfo::AckType_MIN;
constexpr AckInfo_AckType AckInfo::AckType_MAX;
constexpr int AckInfo::AckType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AckInfo_AckStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_cmcdata_2eproto);
  return file_level_enum_descriptors_cmcdata_2eproto[4];
}
bool AckInfo_AckStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AckInfo_AckStatus AckInfo::NULLSTATUS;
constexpr AckInfo_AckStatus AckInfo::OK;
constexpr AckInfo_AckStatus AckInfo::FAIL;
constexpr AckInfo_AckStatus AckInfo::AckStatus_MIN;
constexpr AckInfo_AckStatus AckInfo::AckStatus_MAX;
constexpr int AckInfo::AckStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMCData_DataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_cmcdata_2eproto);
  return file_level_enum_descriptors_cmcdata_2eproto[5];
}
bool CMCData_DataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMCData_DataType CMCData::NULLTYPE;
constexpr CMCData_DataType CMCData::COMMANDINFO;
constexpr CMCData_DataType CMCData::KVDATA;
constexpr CMCData_DataType CMCData::HASHSLOTINFO;
constexpr CMCData_DataType CMCData::HEARTINFO;
constexpr CMCData_DataType CMCData::ACKINFO;
constexpr CMCData_DataType CMCData::DataType_MIN;
constexpr CMCData_DataType CMCData::DataType_MAX;
constexpr int CMCData::DataType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class HashSlotInfo_CacheNodeInfo::_Internal {
 public:
};

HashSlotInfo_CacheNodeInfo::HashSlotInfo_CacheNodeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HashSlotInfo.CacheNodeInfo)
}
HashSlotInfo_CacheNodeInfo::HashSlotInfo_CacheNodeInfo(const HashSlotInfo_CacheNodeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ip().empty()) {
    ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip(), 
      GetArenaForAllocation());
  }
  slots_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    slots_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_slots().empty()) {
    slots_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_slots(), 
      GetArenaForAllocation());
  }
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:HashSlotInfo.CacheNodeInfo)
}

inline void HashSlotInfo_CacheNodeInfo::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
slots_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  slots_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
port_ = 0;
}

HashSlotInfo_CacheNodeInfo::~HashSlotInfo_CacheNodeInfo() {
  // @@protoc_insertion_point(destructor:HashSlotInfo.CacheNodeInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void HashSlotInfo_CacheNodeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  slots_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void HashSlotInfo_CacheNodeInfo::ArenaDtor(void* object) {
  HashSlotInfo_CacheNodeInfo* _this = reinterpret_cast< HashSlotInfo_CacheNodeInfo* >(object);
  (void)_this;
}
void HashSlotInfo_CacheNodeInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HashSlotInfo_CacheNodeInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HashSlotInfo_CacheNodeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:HashSlotInfo.CacheNodeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  ip_.ClearToEmpty();
  slots_.ClearToEmpty();
  port_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HashSlotInfo_CacheNodeInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "HashSlotInfo.CacheNodeInfo.name"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "HashSlotInfo.CacheNodeInfo.ip"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes slots = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_slots();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HashSlotInfo_CacheNodeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HashSlotInfo.CacheNodeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "HashSlotInfo.CacheNodeInfo.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string ip = 2;
  if (!this->_internal_ip().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ip().data(), static_cast<int>(this->_internal_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "HashSlotInfo.CacheNodeInfo.ip");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ip(), target);
  }

  // int32 port = 3;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_port(), target);
  }

  // bytes slots = 4;
  if (!this->_internal_slots().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_slots(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HashSlotInfo.CacheNodeInfo)
  return target;
}

size_t HashSlotInfo_CacheNodeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HashSlotInfo.CacheNodeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string ip = 2;
  if (!this->_internal_ip().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  // bytes slots = 4;
  if (!this->_internal_slots().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_slots());
  }

  // int32 port = 3;
  if (this->_internal_port() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HashSlotInfo_CacheNodeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HashSlotInfo_CacheNodeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HashSlotInfo_CacheNodeInfo::GetClassData() const { return &_class_data_; }

void HashSlotInfo_CacheNodeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<HashSlotInfo_CacheNodeInfo *>(to)->MergeFrom(
      static_cast<const HashSlotInfo_CacheNodeInfo &>(from));
}


void HashSlotInfo_CacheNodeInfo::MergeFrom(const HashSlotInfo_CacheNodeInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HashSlotInfo.CacheNodeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_ip().empty()) {
    _internal_set_ip(from._internal_ip());
  }
  if (!from._internal_slots().empty()) {
    _internal_set_slots(from._internal_slots());
  }
  if (from._internal_port() != 0) {
    _internal_set_port(from._internal_port());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HashSlotInfo_CacheNodeInfo::CopyFrom(const HashSlotInfo_CacheNodeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HashSlotInfo.CacheNodeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashSlotInfo_CacheNodeInfo::IsInitialized() const {
  return true;
}

void HashSlotInfo_CacheNodeInfo::InternalSwap(HashSlotInfo_CacheNodeInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_, lhs_arena,
      &other->ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &slots_, lhs_arena,
      &other->slots_, rhs_arena
  );
  swap(port_, other->port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HashSlotInfo_CacheNodeInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_cmcdata_2eproto_getter, &descriptor_table_cmcdata_2eproto_once,
      file_level_metadata_cmcdata_2eproto[0]);
}

// ===================================================================

class HashSlotInfo::_Internal {
 public:
  static const ::HashSlotInfo_CacheNodeInfo& cache_node(const HashSlotInfo* msg);
};

const ::HashSlotInfo_CacheNodeInfo&
HashSlotInfo::_Internal::cache_node(const HashSlotInfo* msg) {
  return *msg->cache_node_;
}
HashSlotInfo::HashSlotInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  cache_nodes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HashSlotInfo)
}
HashSlotInfo::HashSlotInfo(const HashSlotInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      cache_nodes_(from.cache_nodes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cache_node()) {
    cache_node_ = new ::HashSlotInfo_CacheNodeInfo(*from.cache_node_);
  } else {
    cache_node_ = nullptr;
  }
  hashinfo_type_ = from.hashinfo_type_;
  // @@protoc_insertion_point(copy_constructor:HashSlotInfo)
}

inline void HashSlotInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cache_node_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hashinfo_type_) -
    reinterpret_cast<char*>(&cache_node_)) + sizeof(hashinfo_type_));
}

HashSlotInfo::~HashSlotInfo() {
  // @@protoc_insertion_point(destructor:HashSlotInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void HashSlotInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete cache_node_;
}

void HashSlotInfo::ArenaDtor(void* object) {
  HashSlotInfo* _this = reinterpret_cast< HashSlotInfo* >(object);
  (void)_this;
}
void HashSlotInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HashSlotInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HashSlotInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:HashSlotInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cache_nodes_.Clear();
  if (GetArenaForAllocation() == nullptr && cache_node_ != nullptr) {
    delete cache_node_;
  }
  cache_node_ = nullptr;
  hashinfo_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HashSlotInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .HashSlotInfo.HashInfoType hashinfo_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hashinfo_type(static_cast<::HashSlotInfo_HashInfoType>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .HashSlotInfo.CacheNodeInfo cache_nodes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cache_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .HashSlotInfo.CacheNodeInfo cache_node = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cache_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HashSlotInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HashSlotInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .HashSlotInfo.HashInfoType hashinfo_type = 1;
  if (this->_internal_hashinfo_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_hashinfo_type(), target);
  }

  // repeated .HashSlotInfo.CacheNodeInfo cache_nodes = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cache_nodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_cache_nodes(i), target, stream);
  }

  // .HashSlotInfo.CacheNodeInfo cache_node = 3;
  if (this->_internal_has_cache_node()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::cache_node(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HashSlotInfo)
  return target;
}

size_t HashSlotInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HashSlotInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .HashSlotInfo.CacheNodeInfo cache_nodes = 2;
  total_size += 1UL * this->_internal_cache_nodes_size();
  for (const auto& msg : this->cache_nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .HashSlotInfo.CacheNodeInfo cache_node = 3;
  if (this->_internal_has_cache_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cache_node_);
  }

  // .HashSlotInfo.HashInfoType hashinfo_type = 1;
  if (this->_internal_hashinfo_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hashinfo_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HashSlotInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HashSlotInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HashSlotInfo::GetClassData() const { return &_class_data_; }

void HashSlotInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<HashSlotInfo *>(to)->MergeFrom(
      static_cast<const HashSlotInfo &>(from));
}


void HashSlotInfo::MergeFrom(const HashSlotInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HashSlotInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cache_nodes_.MergeFrom(from.cache_nodes_);
  if (from._internal_has_cache_node()) {
    _internal_mutable_cache_node()->::HashSlotInfo_CacheNodeInfo::MergeFrom(from._internal_cache_node());
  }
  if (from._internal_hashinfo_type() != 0) {
    _internal_set_hashinfo_type(from._internal_hashinfo_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HashSlotInfo::CopyFrom(const HashSlotInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HashSlotInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HashSlotInfo::IsInitialized() const {
  return true;
}

void HashSlotInfo::InternalSwap(HashSlotInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  cache_nodes_.InternalSwap(&other->cache_nodes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HashSlotInfo, hashinfo_type_)
      + sizeof(HashSlotInfo::hashinfo_type_)
      - PROTOBUF_FIELD_OFFSET(HashSlotInfo, cache_node_)>(
          reinterpret_cast<char*>(&cache_node_),
          reinterpret_cast<char*>(&other->cache_node_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HashSlotInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_cmcdata_2eproto_getter, &descriptor_table_cmcdata_2eproto_once,
      file_level_metadata_cmcdata_2eproto[1]);
}

// ===================================================================

class CommandInfo::_Internal {
 public:
};

CommandInfo::CommandInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CommandInfo)
}
CommandInfo::CommandInfo(const CommandInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  param1_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    param1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_param1().empty()) {
    param1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_param1(), 
      GetArenaForAllocation());
  }
  param2_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    param2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_param2().empty()) {
    param2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_param2(), 
      GetArenaForAllocation());
  }
  cmd_type_ = from.cmd_type_;
  // @@protoc_insertion_point(copy_constructor:CommandInfo)
}

inline void CommandInfo::SharedCtor() {
param1_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  param1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
param2_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  param2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cmd_type_ = 0;
}

CommandInfo::~CommandInfo() {
  // @@protoc_insertion_point(destructor:CommandInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CommandInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  param1_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  param2_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CommandInfo::ArenaDtor(void* object) {
  CommandInfo* _this = reinterpret_cast< CommandInfo* >(object);
  (void)_this;
}
void CommandInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CommandInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommandInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CommandInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  param1_.ClearToEmpty();
  param2_.ClearToEmpty();
  cmd_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CommandInfo.CmdType cmd_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_cmd_type(static_cast<::CommandInfo_CmdType>(val));
        } else
          goto handle_unusual;
        continue;
      // string param1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_param1();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CommandInfo.param1"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string param2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_param2();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CommandInfo.param2"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommandInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CommandInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CommandInfo.CmdType cmd_type = 1;
  if (this->_internal_cmd_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_cmd_type(), target);
  }

  // string param1 = 2;
  if (!this->_internal_param1().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_param1().data(), static_cast<int>(this->_internal_param1().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CommandInfo.param1");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_param1(), target);
  }

  // string param2 = 3;
  if (!this->_internal_param2().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_param2().data(), static_cast<int>(this->_internal_param2().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CommandInfo.param2");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_param2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CommandInfo)
  return target;
}

size_t CommandInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CommandInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string param1 = 2;
  if (!this->_internal_param1().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_param1());
  }

  // string param2 = 3;
  if (!this->_internal_param2().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_param2());
  }

  // .CommandInfo.CmdType cmd_type = 1;
  if (this->_internal_cmd_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cmd_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CommandInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandInfo::GetClassData() const { return &_class_data_; }

void CommandInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CommandInfo *>(to)->MergeFrom(
      static_cast<const CommandInfo &>(from));
}


void CommandInfo::MergeFrom(const CommandInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CommandInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_param1().empty()) {
    _internal_set_param1(from._internal_param1());
  }
  if (!from._internal_param2().empty()) {
    _internal_set_param2(from._internal_param2());
  }
  if (from._internal_cmd_type() != 0) {
    _internal_set_cmd_type(from._internal_cmd_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandInfo::CopyFrom(const CommandInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CommandInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandInfo::IsInitialized() const {
  return true;
}

void CommandInfo::InternalSwap(CommandInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &param1_, lhs_arena,
      &other->param1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &param2_, lhs_arena,
      &other->param2_, rhs_arena
  );
  swap(cmd_type_, other->cmd_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_cmcdata_2eproto_getter, &descriptor_table_cmcdata_2eproto_once,
      file_level_metadata_cmcdata_2eproto[2]);
}

// ===================================================================

class KvData::_Internal {
 public:
};

KvData::KvData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:KvData)
}
KvData::KvData(const KvData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_value().empty()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:KvData)
}

inline void KvData::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KvData::~KvData() {
  // @@protoc_insertion_point(destructor:KvData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KvData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KvData::ArenaDtor(void* object) {
  KvData* _this = reinterpret_cast< KvData* >(object);
  (void)_this;
}
void KvData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KvData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KvData::Clear() {
// @@protoc_insertion_point(message_clear_start:KvData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_.ClearToEmpty();
  value_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KvData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "KvData.key"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "KvData.value"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KvData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:KvData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "KvData.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "KvData.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:KvData)
  return target;
}

size_t KvData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:KvData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string value = 2;
  if (!this->_internal_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KvData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KvData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KvData::GetClassData() const { return &_class_data_; }

void KvData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KvData *>(to)->MergeFrom(
      static_cast<const KvData &>(from));
}


void KvData::MergeFrom(const KvData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:KvData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _internal_set_key(from._internal_key());
  }
  if (!from._internal_value().empty()) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KvData::CopyFrom(const KvData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:KvData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KvData::IsInitialized() const {
  return true;
}

void KvData::InternalSwap(KvData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata KvData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_cmcdata_2eproto_getter, &descriptor_table_cmcdata_2eproto_once,
      file_level_metadata_cmcdata_2eproto[3]);
}

// ===================================================================

class HeartInfo::_Internal {
 public:
};

HeartInfo::HeartInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:HeartInfo)
}
HeartInfo::HeartInfo(const HeartInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&cur_time_, &from.cur_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&cache_status_) -
    reinterpret_cast<char*>(&cur_time_)) + sizeof(cache_status_));
  // @@protoc_insertion_point(copy_constructor:HeartInfo)
}

inline void HeartInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cur_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&cache_status_) -
    reinterpret_cast<char*>(&cur_time_)) + sizeof(cache_status_));
}

HeartInfo::~HeartInfo() {
  // @@protoc_insertion_point(destructor:HeartInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void HeartInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HeartInfo::ArenaDtor(void* object) {
  HeartInfo* _this = reinterpret_cast< HeartInfo* >(object);
  (void)_this;
}
void HeartInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void HeartInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HeartInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:HeartInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&cur_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cache_status_) -
      reinterpret_cast<char*>(&cur_time_)) + sizeof(cache_status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeartInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 cur_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          cur_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HeartInfo.CacheStatus cache_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_cache_status(static_cast<::HeartInfo_CacheStatus>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeartInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:HeartInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 cur_time = 1;
  if (this->_internal_cur_time() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_cur_time(), target);
  }

  // .HeartInfo.CacheStatus cache_status = 2;
  if (this->_internal_cache_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_cache_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:HeartInfo)
  return target;
}

size_t HeartInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HeartInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 cur_time = 1;
  if (this->_internal_cur_time() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cur_time());
  }

  // .HeartInfo.CacheStatus cache_status = 2;
  if (this->_internal_cache_status() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cache_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeartInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    HeartInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeartInfo::GetClassData() const { return &_class_data_; }

void HeartInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<HeartInfo *>(to)->MergeFrom(
      static_cast<const HeartInfo &>(from));
}


void HeartInfo::MergeFrom(const HeartInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HeartInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_cur_time() != 0) {
    _internal_set_cur_time(from._internal_cur_time());
  }
  if (from._internal_cache_status() != 0) {
    _internal_set_cache_status(from._internal_cache_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeartInfo::CopyFrom(const HeartInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HeartInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartInfo::IsInitialized() const {
  return true;
}

void HeartInfo::InternalSwap(HeartInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeartInfo, cache_status_)
      + sizeof(HeartInfo::cache_status_)
      - PROTOBUF_FIELD_OFFSET(HeartInfo, cur_time_)>(
          reinterpret_cast<char*>(&cur_time_),
          reinterpret_cast<char*>(&other->cur_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HeartInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_cmcdata_2eproto_getter, &descriptor_table_cmcdata_2eproto_once,
      file_level_metadata_cmcdata_2eproto[4]);
}

// ===================================================================

class AckInfo::_Internal {
 public:
};

AckInfo::AckInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:AckInfo)
}
AckInfo::AckInfo(const AckInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ack_type_, &from.ack_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&ack_status_) -
    reinterpret_cast<char*>(&ack_type_)) + sizeof(ack_status_));
  // @@protoc_insertion_point(copy_constructor:AckInfo)
}

inline void AckInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ack_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ack_status_) -
    reinterpret_cast<char*>(&ack_type_)) + sizeof(ack_status_));
}

AckInfo::~AckInfo() {
  // @@protoc_insertion_point(destructor:AckInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AckInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AckInfo::ArenaDtor(void* object) {
  AckInfo* _this = reinterpret_cast< AckInfo* >(object);
  (void)_this;
}
void AckInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AckInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AckInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:AckInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&ack_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ack_status_) -
      reinterpret_cast<char*>(&ack_type_)) + sizeof(ack_status_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AckInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .AckInfo.AckType ack_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ack_type(static_cast<::AckInfo_AckType>(val));
        } else
          goto handle_unusual;
        continue;
      // .AckInfo.AckStatus ack_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_ack_status(static_cast<::AckInfo_AckStatus>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AckInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AckInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .AckInfo.AckType ack_type = 1;
  if (this->_internal_ack_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_ack_type(), target);
  }

  // .AckInfo.AckStatus ack_status = 2;
  if (this->_internal_ack_status() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_ack_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AckInfo)
  return target;
}

size_t AckInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AckInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .AckInfo.AckType ack_type = 1;
  if (this->_internal_ack_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ack_type());
  }

  // .AckInfo.AckStatus ack_status = 2;
  if (this->_internal_ack_status() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ack_status());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AckInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AckInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AckInfo::GetClassData() const { return &_class_data_; }

void AckInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AckInfo *>(to)->MergeFrom(
      static_cast<const AckInfo &>(from));
}


void AckInfo::MergeFrom(const AckInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AckInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ack_type() != 0) {
    _internal_set_ack_type(from._internal_ack_type());
  }
  if (from._internal_ack_status() != 0) {
    _internal_set_ack_status(from._internal_ack_status());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AckInfo::CopyFrom(const AckInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AckInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckInfo::IsInitialized() const {
  return true;
}

void AckInfo::InternalSwap(AckInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AckInfo, ack_status_)
      + sizeof(AckInfo::ack_status_)
      - PROTOBUF_FIELD_OFFSET(AckInfo, ack_type_)>(
          reinterpret_cast<char*>(&ack_type_),
          reinterpret_cast<char*>(&other->ack_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AckInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_cmcdata_2eproto_getter, &descriptor_table_cmcdata_2eproto_once,
      file_level_metadata_cmcdata_2eproto[5]);
}

// ===================================================================

class CMCData::_Internal {
 public:
  static const ::HashSlotInfo& hs_info(const CMCData* msg);
  static const ::CommandInfo& cmd_info(const CMCData* msg);
  static const ::KvData& kv_data(const CMCData* msg);
  static const ::HeartInfo& ht_info(const CMCData* msg);
  static const ::AckInfo& ack_info(const CMCData* msg);
};

const ::HashSlotInfo&
CMCData::_Internal::hs_info(const CMCData* msg) {
  return *msg->hs_info_;
}
const ::CommandInfo&
CMCData::_Internal::cmd_info(const CMCData* msg) {
  return *msg->cmd_info_;
}
const ::KvData&
CMCData::_Internal::kv_data(const CMCData* msg) {
  return *msg->kv_data_;
}
const ::HeartInfo&
CMCData::_Internal::ht_info(const CMCData* msg) {
  return *msg->ht_info_;
}
const ::AckInfo&
CMCData::_Internal::ack_info(const CMCData* msg) {
  return *msg->ack_info_;
}
CMCData::CMCData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMCData)
}
CMCData::CMCData(const CMCData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_hs_info()) {
    hs_info_ = new ::HashSlotInfo(*from.hs_info_);
  } else {
    hs_info_ = nullptr;
  }
  if (from._internal_has_cmd_info()) {
    cmd_info_ = new ::CommandInfo(*from.cmd_info_);
  } else {
    cmd_info_ = nullptr;
  }
  if (from._internal_has_kv_data()) {
    kv_data_ = new ::KvData(*from.kv_data_);
  } else {
    kv_data_ = nullptr;
  }
  if (from._internal_has_ht_info()) {
    ht_info_ = new ::HeartInfo(*from.ht_info_);
  } else {
    ht_info_ = nullptr;
  }
  if (from._internal_has_ack_info()) {
    ack_info_ = new ::AckInfo(*from.ack_info_);
  } else {
    ack_info_ = nullptr;
  }
  data_type_ = from.data_type_;
  // @@protoc_insertion_point(copy_constructor:CMCData)
}

inline void CMCData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hs_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&data_type_) -
    reinterpret_cast<char*>(&hs_info_)) + sizeof(data_type_));
}

CMCData::~CMCData() {
  // @@protoc_insertion_point(destructor:CMCData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMCData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete hs_info_;
  if (this != internal_default_instance()) delete cmd_info_;
  if (this != internal_default_instance()) delete kv_data_;
  if (this != internal_default_instance()) delete ht_info_;
  if (this != internal_default_instance()) delete ack_info_;
}

void CMCData::ArenaDtor(void* object) {
  CMCData* _this = reinterpret_cast< CMCData* >(object);
  (void)_this;
}
void CMCData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMCData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMCData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMCData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && hs_info_ != nullptr) {
    delete hs_info_;
  }
  hs_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && cmd_info_ != nullptr) {
    delete cmd_info_;
  }
  cmd_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && kv_data_ != nullptr) {
    delete kv_data_;
  }
  kv_data_ = nullptr;
  if (GetArenaForAllocation() == nullptr && ht_info_ != nullptr) {
    delete ht_info_;
  }
  ht_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && ack_info_ != nullptr) {
    delete ack_info_;
  }
  ack_info_ = nullptr;
  data_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMCData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CMCData.DataType data_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_data_type(static_cast<::CMCData_DataType>(val));
        } else
          goto handle_unusual;
        continue;
      // .HashSlotInfo hs_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_hs_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CommandInfo cmd_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cmd_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .KvData kv_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_kv_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .HeartInfo ht_info = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ht_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .AckInfo ack_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_ack_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMCData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMCData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CMCData.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_data_type(), target);
  }

  // .HashSlotInfo hs_info = 2;
  if (this->_internal_has_hs_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::hs_info(this), target, stream);
  }

  // .CommandInfo cmd_info = 3;
  if (this->_internal_has_cmd_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::cmd_info(this), target, stream);
  }

  // .KvData kv_data = 4;
  if (this->_internal_has_kv_data()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::kv_data(this), target, stream);
  }

  // .HeartInfo ht_info = 5;
  if (this->_internal_has_ht_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::ht_info(this), target, stream);
  }

  // .AckInfo ack_info = 6;
  if (this->_internal_has_ack_info()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::ack_info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMCData)
  return target;
}

size_t CMCData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMCData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .HashSlotInfo hs_info = 2;
  if (this->_internal_has_hs_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *hs_info_);
  }

  // .CommandInfo cmd_info = 3;
  if (this->_internal_has_cmd_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cmd_info_);
  }

  // .KvData kv_data = 4;
  if (this->_internal_has_kv_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *kv_data_);
  }

  // .HeartInfo ht_info = 5;
  if (this->_internal_has_ht_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ht_info_);
  }

  // .AckInfo ack_info = 6;
  if (this->_internal_has_ack_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ack_info_);
  }

  // .CMCData.DataType data_type = 1;
  if (this->_internal_data_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMCData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMCData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMCData::GetClassData() const { return &_class_data_; }

void CMCData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMCData *>(to)->MergeFrom(
      static_cast<const CMCData &>(from));
}


void CMCData::MergeFrom(const CMCData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMCData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hs_info()) {
    _internal_mutable_hs_info()->::HashSlotInfo::MergeFrom(from._internal_hs_info());
  }
  if (from._internal_has_cmd_info()) {
    _internal_mutable_cmd_info()->::CommandInfo::MergeFrom(from._internal_cmd_info());
  }
  if (from._internal_has_kv_data()) {
    _internal_mutable_kv_data()->::KvData::MergeFrom(from._internal_kv_data());
  }
  if (from._internal_has_ht_info()) {
    _internal_mutable_ht_info()->::HeartInfo::MergeFrom(from._internal_ht_info());
  }
  if (from._internal_has_ack_info()) {
    _internal_mutable_ack_info()->::AckInfo::MergeFrom(from._internal_ack_info());
  }
  if (from._internal_data_type() != 0) {
    _internal_set_data_type(from._internal_data_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMCData::CopyFrom(const CMCData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMCData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMCData::IsInitialized() const {
  return true;
}

void CMCData::InternalSwap(CMCData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMCData, data_type_)
      + sizeof(CMCData::data_type_)
      - PROTOBUF_FIELD_OFFSET(CMCData, hs_info_)>(
          reinterpret_cast<char*>(&hs_info_),
          reinterpret_cast<char*>(&other->hs_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMCData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_cmcdata_2eproto_getter, &descriptor_table_cmcdata_2eproto_once,
      file_level_metadata_cmcdata_2eproto[6]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::HashSlotInfo_CacheNodeInfo* Arena::CreateMaybeMessage< ::HashSlotInfo_CacheNodeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HashSlotInfo_CacheNodeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::HashSlotInfo* Arena::CreateMaybeMessage< ::HashSlotInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HashSlotInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CommandInfo* Arena::CreateMaybeMessage< ::CommandInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CommandInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::KvData* Arena::CreateMaybeMessage< ::KvData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::KvData >(arena);
}
template<> PROTOBUF_NOINLINE ::HeartInfo* Arena::CreateMaybeMessage< ::HeartInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::HeartInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::AckInfo* Arena::CreateMaybeMessage< ::AckInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AckInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMCData* Arena::CreateMaybeMessage< ::CMCData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMCData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
